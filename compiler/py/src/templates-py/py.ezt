#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

from thrift.Thrift import *
[# ### probably need some massaging to really locate this module
][for includes]import [includes].ttypes
[end]
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


[# ### need gen_newstyle flag
][for enums]class [enums.ident](object):[for enums.values]
  [enums.values.ident] = [enums.values.value][end]
[end]

[for consts][consts.ident] = [consts.value.cvalue]
[end]

[# ### need gen_newstyle flag
][for structs]class [structs.ident](object):

  thrift_spec = ([# ### should sort fields. need None markers for gaps.
][if-any structs.fields][for structs.sorted_fields]
    [if-any structs.sorted_fields]([structs.sorted_fields.field_id], [structs.sorted_fields.type_enum], [#
]'[structs.sorted_fields.ident]', [#
]None, [# ### should have spec_args here
][if-any structs.sorted_fields.value][structs.sorted_fields.value.cvalue][else]None[end], [#
]),[else]None,[end] # ### list-index[# structs.sorted_fields.list-index][end]
  )
[else]  thrift_spec = None
[end]
[if-any structs.fields]  def __init__(self,[#
][for structs.fields] [structs.fields.ident]=[#
][if-any structs.fields.value]thrift_spec[[][structs.fields.field_id]][[]4][#
][else]None[end],[end]):
[for structs.fields][if-any ""][# ### complex test here
]    if [structs.fields.ident] is self.thrift_spec[[]structs.fields.field_id][[]4]:
      [structs.fields.ident] = [structs.fields.value.cvalue]
[end]    self.[structs.fields.ident] = [structs.fields.ident]
[end]
[end][# close: if-any structs.fields]

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated [#
]and isinstance(iprot.trans, TTransport.CReadableTransport) [#
]and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, [#
](self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break[for structs.fields]
      [if-index structs.fields first]if[else]elif[end] fid == [#
][structs.fields.field_id]:
        if ftype == [structs.fields.type_enum]:
          pass # deserialize
        else:
          iprot.skip(ftype)[end]
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated [#
]and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, [#
](self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('[structs.ident]')[for structs.fields]
    if self.[structs.fields.ident] != None:
      oprot.writeFieldBegin('[structs.fields.ident]', [#
][structs.fields.type_enum], [structs.fields.field_id])
      # serialize
      oprot.writeFieldEnd()[end]
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = [[]'%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

[end][# for structs]
